[CmdletBinding(DefaultParameterSetName = 'withFile')]
param (
    [Parameter(Mandatory)]
    [ValidateNotNullOrEmpty()]
    [string]$ModuleLibPath,

    [Parameter(
        Mandatory,
        ParameterSetName = 'withFile'
    )]
    [ValidateNotNullOrEmpty()]
    [string]$DestinationFile,

    [Parameter(
        ParameterSetName = 'withFile'
    )]
    [switch]$Force,

    [Parameter(
        ParameterSetName = 'withConsole'
    )]
    [switch]$PrintToConsole
)

$ErrorActionPreference = 'Stop'

#region Functions

function Get-CmdletInitials {

    [CmdletBinding()]
    param (
        [Parameter(
            Mandatory,
            Position = 0
        )]
        [ValidateNotNullOrEmpty()]
        [string]$CmdletName
    )

    $buffer = [System.Text.StringBuilder]::new()
    [void]$buffer.Append($CmdletName[0])

    $indexOfDash = $CmdletName.IndexOf('-')
    [void]$buffer.Append($CmdletName[$indexOfDash + 1])
    for ($i = $indexOfDash + 2; $i -lt $CmdletName.Length; $i++) {
        $currentChar = $CmdletName[$i]
        if ([char]::IsUpper($currentChar)) {
            [void]$buffer.Append($currentChar)
        }
    }

    return $buffer.ToString()
}

function Get-CapitalizedString([string]$String) {
    return $String[0].ToString().ToUpper() + $String.Substring(1)
}

#endregion

#region ParameterValidation

if (!$PrintToConsole) {
    $outputFileInfo = [System.IO.FileInfo]::new($DestinationFile)
    $destinationDirectory = [System.IO.Path]::GetDirectoryName($DestinationFile)
    if (![System.IO.Directory]::Exists($destinationDirectory)) {
        throw [System.IO.FileNotFoundException]::new("Output file directory '$destinationDirectory' not found.")
    }
    
    if ($outputFileInfo.Exists -and !$Force) {
        throw [InvalidOperationException]::new("Output file '$($outputFileInfo.Nam)' already exists. Use '-Force' to overwrite it.")
    }
}

$moduleLibName = [System.IO.Path]::GetFileName($ModuleLibPath)
if ($moduleLibName -ne 'WindowsUtils.dll') {
    throw [ArgumentException]::new("Invalid module library '$moduleLibName'.")
}

if (![System.IO.File]::Exists($ModuleLibPath)) {
    throw [System.IO.FileNotFoundException]::new("Could not find the module library file '$ModuleLibPath'.")
}

#endregion

#region InitialSetup

Import-Module $ModuleLibPath

$moduleCmdlets = Get-Command -Module 'WindowsUtils'

$disposeOfWriter = $false
if ($PrintToConsole) {
    $writer = [Console]::Out
}
else {
    $fileStream = [System.IO.FileStream]::new($DestinationFile, 'Create', 'ReadWrite', 'None')
    $writer = [System.IO.StreamWriter]::new($fileStream, [System.Text.Encoding]::UTF8, 4KB, $true)
    $disposeOfWriter = $true
}

#endregion

try {
    #region Header

    $writer.WriteLine(@'
<!--
    This file was generated by a tool. See '.\Tools\Helpers\CreatePesterTestCasesTemplate.ps1'.
    PLEASE DO NOT MODIFY BY HAND.
-->

# WindowsUtils Pester Test Cases

This document contains the conceptual test cases for each module's Cmdlet.  
These test cases cover only Cmdlet tests. For `WuCore` test cases see [WindowsUtils Core Test Cases](/src/WuCore/Tests/TestCases.md).  
For the .NET engine test cases see [WindowsUtils Engine Test Cases](/src/Tests/TestCases.md).  

<!-- omit in toc -->
## Table of Contents

- [WindowsUtils Pester Test Cases](#windowsutils-pester-test-cases)
'@)

    #endregion

    #region TOC

    $cmdletInitialsMap = [System.Collections.Generic.Dictionary[string, string]]::new()
    foreach ($cmdlet in $moduleCmdlets) {
        $initials = Get-CmdletInitials $cmdlet
        if ($cmdletInitialsMap.ContainsValue($initials)) {
            $initials = "$($initials)1"
        }

        $cmdletInitialsMap.Add($cmdlet.Name, $initials)
        $inToLower = $initials.ToLower()
        $writer.WriteLine("  - [$cmdlet \[$initials\]](#$($cmdlet.Name.ToLower())-$inToLower)")
        $writer.WriteLine("    - [\[$initials\] - Intent](#$inToLower---intent)")
        $writer.WriteLine("    - [\[$initials\] - Parameters](#$inToLower---parameters)")
        $writer.WriteLine("    - [\[$initials\] - Output](#$inToLower---output)")
        $writer.WriteLine("    - [\[$initials\] - Should](#$inToLower---should)")
    }

    $writer.WriteLine()

    #endregion

    #region Cmdlets

    $commonParameters = @(
        'Debug'
        'ErrorAction'
        'ErrorVariable'
        'InformationAction'
        'InformationVariable'
        'OutVariable'
        'OutBuffer'
        'PipelineVariable'
        'ProgressAction'
        'Verbose'
        'WarningAction'
        'WarningVariable'
        'WhatIf'
        'Confirm'
    )

    $index = 0
    foreach ($cmdlet in $moduleCmdlets) {
        
        # Headers.
        $initials = $cmdletInitialsMap[$cmdlet.Name]
        $writer.WriteLine("## $($cmdlet.Name) [$initials]`n")
        $writer.WriteLine("### [$initials] - Intent`n")

        $description = (Get-Help -Name $cmdlet.Name).description.Text
        if ($description) {
            if ($description.GetType().Name -ne 'String') {
                $description = $description[0].Trim()
            }
        }
        else {
            $description = 'None.'
        }

        $writer.WriteLine("$description  `n")
        $writer.WriteLine("### [$initials] - Parameters`n")
        
        # Parameters.
        $hadParameters = $false
        foreach ($parameter in $cmdlet.Parameters.Keys) {
            if ($commonParameters.Contains($parameter)) {
                continue
            }

            $currentParam = $cmdlet.Parameters[$parameter]
            $paramHelp = Get-Help -Name $cmdlet.Name -Parameter $parameter

            $paramSetNamesBuff = [System.Text.StringBuilder]::new()
            if ($currentParam.ParameterSets.Count -gt 0) {
                foreach ($psn in $currentParam.ParameterSets.Keys) {
                    [void]$paramSetNamesBuff.Append("$psn, ")
                }
    
                [void]$paramSetNamesBuff.Remove($paramSetNamesBuff.Length - 2, 2)
            }
            else {
                [void]$paramSetNamesBuff.Append('None')
            }

            $pipelineInput = $paramHelp.pipelineInput
            $spaceIndex = $pipelineInput.IndexOf(' ')
            if ($spaceIndex -ne -1) {
                $pipelineInput = "``$(Get-CapitalizedString($pipelineInput.Substring(0, $spaceIndex)))``. $($pipelineInput.Substring($spaceIndex) -replace '\(|\)')"
            }
            else {
                $pipelineInput = "``$(Get-CapitalizedString($pipelineInput))``"
            }

            $writer.WriteLine("- $parameter")
            $writer.WriteLine("  - Description: $($paramHelp.description.Text.Replace("`n", ' '))")
            $writer.WriteLine("  - Type: ``$($currentParam.ParameterType.FullName)``.")
            $writer.WriteLine("  - Mandatory: ``$(Get-CapitalizedString($paramHelp.required))``.")
            $writer.WriteLine("  - Value from pipeline: $pipelineInput.")
            $writer.WriteLine("  - Parameter set names: ``$($paramSetNamesBuff.ToString())``.")

            $hadParameters = $true
        }

        if (!$hadParameters) {
            $writer.WriteLine('None.')
        }

        $writer.WriteLine()

        # Output.
        $writer.WriteLine("### [$initials] - Output`n")

        $otBuffer = [System.Text.StringBuilder]::new()
        if ($cmdlet.OutputType.Count -gt 0) {
            foreach ($outputType in $cmdlet.OutputType) {
                [void]$otBuffer.Append("$($outputType.Name), ")
            }

            [void]$otBuffer.Remove($otBuffer.Length - 2, 2)
        }
        else {
            [void]$otBuffer.Append('None')
        }

        $writer.WriteLine("$($otBuffer.ToString()).`n")

        # Should.
        # Using the paragraph tag (<p></p>) to generate a warning for using explicit HTML.
        # This way we can easily find the ones we need to write the cases.
        $writer.WriteLine("### [$initials] - Should`n")
        if ($index + 1 -lt $moduleCmdlets.Count) {
            $writer.WriteLine("<p>!! INPUT YOUR TEST CASES HERE !!</p>`n")
        }
        else {
            $writer.WriteLine("<p>!! INPUT YOUR TEST CASES HERE !!</p>")
        }

        $index++
    }

    #endregion
}
finally {
    if ($writer -and $disposeOfWriter) { $writer.Dispose() }
    if ($fileStream) { $fileStream.Dispose() }
}